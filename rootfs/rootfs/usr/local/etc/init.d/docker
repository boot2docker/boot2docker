#!/bin/sh
# docker daemon start script
[ $(id -u) = 0 ] || { echo 'must be root' ; exit 1; }

#import settings from profile (e.g. HTTP_PROXY, HTTPS_PROXY)
test -f '/var/lib/boot2docker/profile' && . '/var/lib/boot2docker/profile'

: ${DOCKER_STORAGE:=auto}
: ${DOCKER_DIR:=/var/lib/docker}
: ${DOCKER_ULIMITS:=1048576}
: ${DOCKER_LOGFILE:=/var/lib/boot2docker/docker.log}

# before setting defaults, let's check what was in /var/lib/boot2docker/profile
if [ -n "$DOCKER_TLS" -a -z "$DOCKER_REMOTE" ]; then
	# if /var/lib/boot2docker/profile sets DOCKER_TLS but not DOCKER_REMOTE, assume
	DOCKER_REMOTE=yes
fi

: ${DOCKER_REMOTE:=no} # 'yes' or anything else for 'no'
: ${DOCKER_TLS:=yes} # 'no' or anything else for 'yes' (obviously has no effect if DOCKER_REMOTE is not explicitly "yes")
: ${CERT_INTERFACES:='eth0 eth1'}
: ${CERTDIR:=/var/lib/boot2docker/tls}
: ${CACERT:="${CERTDIR}/ca.pem"}
: ${CAKEY:="${CERTDIR}/cakey.pem"}
: ${CASRL:="${CERTDIR}/ca.srl"}
: ${SERVERCERT:="${CERTDIR}/server.pem"}
: ${SERVERKEY:="${CERTDIR}/serverkey.pem"}
: ${SERVERCSR:="${CERTDIR}/server.csr"}
: ${CERT:="${CERTDIR}/client.pem"}
: ${KEY:="${CERTDIR}/clientkey.pem"}
: ${CSR:="${CERTDIR}/client.csr"}
: ${ORG:=Boot2Docker}
: ${SERVERORG:="${ORG}"}
: ${CAORG:="${ORG} CA"} # Append 'CA'; see <http://rt.openssl.org/Ticket/History.html?id=3979>

USERHOME="$(awk -F: '$1 == "docker" { print $6; exit }' /etc/passwd)"
: ${USERHOME:=/home/docker}
USERUIDGID="$(awk -F: '$1 == "docker" { print $3 ":" $4; exit }' /etc/passwd)"
: ${USERUIDGID:=docker}
USERCFG="$USERHOME/.docker"

# Add /usr/local/sbin to the path.
export PATH=${PATH}:/usr/local/sbin

start() {
	if [ 'yes' = "$DOCKER_REMOTE" ]; then
		if [ 'no' = "$DOCKER_TLS" ]; then
			EXTRA_ARGS="$EXTRA_ARGS -H tcp://0.0.0.0:2375"
		else
			# see https://docs.docker.com/articles/https/
			# and https://gist.github.com/Stono/7e6fed13cfd79598eb15
			EXTRA_ARGS="$EXTRA_ARGS -H tcp://0.0.0.0:2376 --tlsverify"
			mkdir -p "$CERTDIR"
			chmod 700 "$CERTDIR"
			if [ ! -f "$CAKEY" ]; then
				echo "Generating $CAKEY"
				openssl genrsa \
					-out "$CAKEY" \
					4096
			fi
			if [ ! -f "$CACERT" ]; then
				echo "Generating $CACERT"
				openssl req \
					-new \
					-key "$CAKEY" \
					-x509 \
					-days 365 \
					-nodes \
					-subj "/O=$CAORG" \
					-out "$CACERT"
			fi
			EXTRA_ARGS="$EXTRA_ARGS --tlscacert=$CACERT"
			if [ ! -f "$CASRL" ]; then
				echo '01' > "$CASRL"
			fi
			if [ ! -f "$SERVERKEY" ]; then
				echo "Generating $SERVERKEY"
				openssl genrsa \
					-out "$SERVERKEY" \
					4096
			fi
			EXTRA_ARGS="$EXTRA_ARGS --tlskey=$SERVERKEY"
			if [ ! -f "$SERVERCERT" ]; then
				echo "Generating $SERVERCERT"
				commonName="$(hostname -s)"
				altName="IP:$(hostname -i)"
				altName="$altName,IP:127.0.0.1"
				altName="$altName,DNS:localhost,DNS:localhost.local"
				altName="$altName,IP:::1"
				altName="$altName,DNS:ip6-localhost,DNS:ip6-loopback"
				for interface in $CERT_INTERFACES; do
					ips=$(ip addr show "$interface" | awk -F '[/[:space:]]+' '$2 == "inet" { print $3 }')
					for ip in $ips; do
						altName="$altName,IP:$ip"
					done
				done
				openssl req \
					-new \
					-key "$SERVERKEY" \
					-subj "/O=$SERVERORG/CN=$commonName" \
					-out "$SERVERCSR"
				extfile="$CERTDIR/extfile.cnf"
				echo "subjectAltName = $altName" > "$extfile"
				openssl x509 \
					-req \
					-days 365 \
					-in "$SERVERCSR" \
					-CA "$CACERT" \
					-CAkey "$CAKEY" \
					-out "$SERVERCERT" \
					-extfile "$extfile"
				rm "$extfile"
			fi
			EXTRA_ARGS="$EXTRA_ARGS --tlscert=$SERVERCERT"
			if [ ! -f "$KEY" ]; then
				echo "Generating $KEY"
				openssl genrsa \
					-out "$KEY" \
					4096
			fi
			if [ ! -f "$CERT" ]; then
				echo "Generating $CERT"
				openssl req \
					-new \
					-key "$KEY" \
					-subj "/O=$ORG" \
					-out "$CSR"
				extfile="$CERTDIR/extfile.cnf"
				echo 'extendedKeyUsage = clientAuth' > "$extfile"
				openssl x509 \
					-req \
					-days 365 \
					-in "$CSR" \
					-CA "$CACERT" \
					-CAkey "$CAKEY" \
					-out "$CERT" \
					-extfile "$extfile"
				rm "$extfile"
			fi
			mkdir -p "$USERCFG"
			chmod 700 "$USERCFG"
			chown "$USERUIDGID" "$USERCFG"
			cp "$CACERT" "$USERCFG/ca.pem"
			chown "$USERUIDGID" "$USERCFG/ca.pem"
			cp "$CERT" "$USERCFG/cert.pem"
			chown "$USERUIDGID" "$USERCFG/cert.pem"
			cp "$KEY" "$USERCFG/key.pem"
			chmod 700 "$USERCFG/key.pem"
			chown "$USERUIDGID" "$USERCFG/key.pem"
		fi
	fi

    mkdir -p "$DOCKER_DIR"

    if [ "$DOCKER_STORAGE" = 'auto' ]; then
        # if /var/lib/docker is on BTRFS, let's use the native btrfs driver
        # (AUFS on top of BTRFS does very bad things)
        DOCKER_DEVICE="$(/bin/df -P "$DOCKER_DIR" | /usr/bin/awk 'END { print $1 }')"
        DOCKER_FSTYPE="$(/sbin/blkid -o export "$DOCKER_DEVICE" | /bin/grep TYPE= | /usr/bin/cut -d= -f2)"
        if [ "$DOCKER_FSTYPE" = 'btrfs' ]; then
            DOCKER_STORAGE="$DOCKER_FSTYPE"
        fi
    fi
    if [ "$DOCKER_STORAGE" != 'auto' ]; then
        # in the general case, let's trust Docker to "do the right thing"
        EXTRA_ARGS="$EXTRA_ARGS -s $DOCKER_STORAGE"
    fi

    # Increasing the number of open files and processes by docker
    ulimit -n $DOCKER_ULIMITS
    ulimit -p $DOCKER_ULIMITS

    echo "------------------------" >> "$DOCKER_LOGFILE"
    echo "/usr/local/bin/docker daemon -D -g \"$DOCKER_DIR\" -H unix:// $EXTRA_ARGS >> \"$DOCKER_LOGFILE\"" >> "$DOCKER_LOGFILE"
    /usr/local/bin/docker daemon -D -g "$DOCKER_DIR" -H unix:// $EXTRA_ARGS >> "$DOCKER_LOGFILE" 2>&1 &
}

stop() {
    kill $(cat /var/run/docker.pid)
}

restart() {
    if check; then
        stop && sleep 1 && start
    else
        start
    fi
}

check() {
    [ -f /var/run/docker.pid ] && ps -A -o pid | grep "^\s*$(cat /var/run/docker.pid)$" > /dev/null 2>&1
}

status() {
    if check; then
        echo 'Docker daemon is running'
        exit 0
    else
        echo 'Docker daemon is not running'
        exit 1
    fi
}

case $1 in
    start) start;;
    stop) stop;;
    restart) restart;;
    status) status;;
    *) echo "Usage $0 {start|stop|restart|status}"; exit 1
esac
